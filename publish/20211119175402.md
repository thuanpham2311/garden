# thần bài với bubble sort

- so sánh từng cập trên từng vị trí của array nếu số trước > số sau thì hoán đổi vị trí của nó, cứ tiếp tục như vậy đến cặp cuối array thì chúng ta được số lớn nhất trong array
- như vậy sau mỗi lần so sánh ta sẽ có số lớn thứ X sau X lần lập
- để tối ưu thuật toán, như niêu trên thì mõi lần lập thì sẽ có số lơn nhất trong vòng lập đó nên sau khi lập vòng đầu tiên thì đương nhiên số lớn nhất ở cuối cùng nên lần lập tiếp theo ta chả cần so sánh tới số lớn nhất đã tìm nữa và cứ như vậy với số lớn thứ 2, 3,...
- ở trong video ông dev có nhắc tới độ phức tạp của thuật toán nếu mình không tối ưu thì độ phức tạp là O², theo suy đoán ban đầu thì độ phức tạp được tính theo vòng lập, thuật toán bubble sort này thì sẽ có 2 vòng lập for
- okey thế tính độ phức tạp của thuật toán bằng cách méo nào? cái này cần tìm hiểu thêm nè.
- nhớ lúc trước mình có copy paste cái thuật toán này, sử dụng 1 hàm swap với 1 hàm triển khai cái bubble sort xài cpp.

```cpp
void swap(int *x, int *y) { \\ cái này không xài con trở thì hỏng được hen, mà còn mơ hồ về cách xài con trỏ trong thực tế qué.
  int tmp = *x; \\ cái tmp này mình lấy cảm hứng từ /tmp một cái thư mục tạm thời trong Linux hình như Unix relative củng có
  *x = *y;
  *y = tmp;
}

void bubbleSort(int array[], int n) {
  int i, j;
  for (i = 0; i < n - 1; i++)
    for (j = 0; j < n - i - 1; j++)
      if (array[j] > array[j + 1]) {
        swap(array[j], array[j + 1]);
      }
}

```

---

- Author: [ông dev](202109112225.md)
- Link: <https://www.youtube.com/watch?v=KsbdeXLau08>

> #video
